---
description: MCP (Model Context Protocol) server architecture and implementation
globs: **/mcp/**
alwaysApply: false
---
# Airweave MCP Server Architecture

## Overview

The Airweave MCP Server provides search capabilities for AI assistants through the Model Context Protocol (MCP). It supports both local desktop clients and cloud-based AI platforms.

## Deployment Modes

### 1. Local Mode (Desktop AI Clients)
- **Transport**: stdio (standard input/output)
- **Target**: Claude Desktop, Cursor, and other desktop AI assistants
- **Entry Point**: `src/index.ts`
- **Installation**: npm package or npx
- **Architecture**: Single-tenant, one server instance per user's local environment
- **Authentication**: API key from environment variables

### 2. Hosted Mode (Cloud AI Platforms)
- **Transport**: Streamable HTTP (MCP 2025-03-26)
- **Target**: OpenAI Agent Builder and cloud-based AI platforms
- **Entry Point**: `src/index-http.ts`
- **Deployment**: Azure Kubernetes Service
- **URL**: `https://mcp.airweave.ai`
- **Architecture**: Multi-tenant, per-session server instances with isolated API keys
- **Authentication**: API key per request via headers or query parameters

**Key Difference**: Hosted mode creates separate `McpServer` instances for each session/API key combination, ensuring complete isolation between different users and allowing API key changes without server restart.

## Architecture Components

### Core Server (`src/server.ts`)
- **McpServer**: Main MCP server instance
- **Tool Registration**: Dynamic tool creation based on collection
- **Airweave Client**: API client for search operations
- **Environment Validation**: Configuration validation for both modes

### Streamable HTTP Server (`src/index-http.ts`)
- **Express App**: HTTP server with health checks and info endpoints
- **Streamable HTTP Transport**: Modern MCP 2025-03-26 transport for bidirectional communication
- **Request Handling**: POST `/mcp` endpoint for all MCP requests
- **Session Management**: Redis-backed distributed sessions with local caching for performance
- **Authentication**: API key extraction from headers or query parameters per request
- **Security**: API key hashing, session binding (IP/User-Agent), rate limiting, audit logging
- **Multi-Collection Discovery**: Dynamically fetches and registers tools for all collections accessible via the API key

### Tools
- **Search Tools**: `search-{readable_id}` - One search tool per collection (e.g., `search-github-test-r9xdw7`, `search-linear-o0yvkc`)
- **Config Tool**: `get-config` - Server configuration display

**Collection Discovery**: On session initialization, the server fetches all collections accessible via the provided API key from `/collections` endpoint and registers a dedicated search tool for each collection. Tool descriptions include collection name, status, and last update time to help LLMs choose the appropriate collection.

## Key Features

### Search Capabilities
- Natural language queries with full parameter control
- AI completion responses
- Pagination control (limit/offset)
- Recency bias configuration
- Score thresholds and filtering

### Authentication
- Multiple API key methods:
  - `Authorization: Bearer <key>`
  - `X-API-Key: <key>`
  - Query parameters: `?apiKey=<key>` or `?api_key=<key>`

### Error Handling
- Comprehensive error responses
- Structured logging with timestamps
- Graceful connection handling

## Configuration

### Environment Variables
- `AIRWEAVE_COLLECTION`: Target collection name
- `AIRWEAVE_BASE_URL`: API base URL (default: production)
- `PORT`: Server port (default: 8080)
- `REDIS_HOST`: Redis server hostname (default: redis)
- `REDIS_PORT`: Redis server port (default: 6379)
- `REDIS_PASSWORD`: Redis authentication password
- `REDIS_URL`: Complete Redis connection string

### Client Configuration
- API key provided by client (not server environment)
- Collection-specific tool naming
- Dynamic configuration per connection

## Implementation Details

### Redis-Backed Session Management Pattern
```typescript
// Local cache: Map session IDs to { server, transport, data }
// This cache is per-pod and reconstructed from Redis as needed
const localSessionCache = new Map<string, SessionWithTransport>();

// Redis session manager for distributed storage
const sessionManager = new RedisSessionManager({
    host: process.env.REDIS_HOST || 'redis',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD
});

// Handle all MCP requests with Redis-backed session persistence
app.post('/mcp', async (req, res) => {
    // Extract API key and client metadata
### Streamable HTTP Transport Pattern with Multi-Collection Discovery
```typescript
// Fetch collections from Airweave API
async function fetchCollections(apiKey: string, baseUrl: string): Promise<any[]> {
    const response = await fetch(`${baseUrl}/collections?limit=100`, {
        headers: { 'X-API-Key': apiKey }
    });
    return await response.json();
}

// Create server with dynamic tool registration based on collections
async function createMcpServer(apiKey: string) {
    const collections = await fetchCollections(apiKey, baseUrl);
    const server = new McpServer({...});
    
    // Register one search tool per collection
    for (const collection of collections) {
        const airweaveClient = new AirweaveClient({ collection: collection.readable_id, baseUrl, apiKey });
        const searchTool = createSearchTool(`search-${collection.readable_id}`, collection.readable_id, airweaveClient);
        
        // Enhanced description with metadata
        const description = `Search within '${collection.name}' collection.
Status: ${collection.status}
Last updated: ${collection.modified_at}
${searchTool.description}`;
        
        server.tool(searchTool.name, description, searchTool.schema, searchTool.handler);
    }
    return server;
}

// Session management with async server creation
const sessions = new Map<string, { server: McpServer, transport: StreamableHTTPServerTransport, apiKey: string }>();

app.post('/mcp', async (req, res) => {
    const apiKey = req.headers['x-api-key'] || req.headers['authorization']?.replace('Bearer ', '');
    const sessionId = req.headers['mcp-session-id'] || generateSessionId();
    const clientIP = req.headers['x-forwarded-for']?.split(',')[0] || req.socket.remoteAddress;
    
    // Check local cache first (fastest path)
    let session = localSessionCache.get(sessionId);
    
    if (!session) {
        // Retrieve from Redis and recreate server instance
        const sessionData = await sessionManager.getSession(sessionId);
        if (sessionData) {
            session = await createSessionObjects(sessionData, apiKey);
            localSessionCache.set(sessionId, session);
        } else {
            // Create new session with rate limiting and security checks
            const rateLimit = await sessionManager.checkRateLimit(apiKey);
            if (!rateLimit.allowed) throw new Error('Rate limit exceeded');
            
            const newSessionData = {
                sessionId,
                apiKeyHash: RedisSessionManager.hashApiKey(apiKey),
                collection: process.env.AIRWEAVE_COLLECTION,
                baseUrl: process.env.AIRWEAVE_BASE_URL,
                clientIP,
                userAgent: req.headers['user-agent']
            };
            await sessionManager.setSession(newSessionData);
            session = await createSessionObjects(newSessionData, apiKey);
            localSessionCache.set(sessionId, session);
        }
    if (!session || session.apiKey !== apiKey) {
        // Async: Fetch collections and create server with all tools
        const server = await createMcpServer(apiKey);
        const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: () => sessionId });
        await server.connect(transport);
        session = { server, transport, apiKey };
        sessions.set(sessionId, session);
    }
    
    await session.transport.handleRequest(req, res, req.body);
});
```

### Tool Registration
- Dynamic tool names based on collection
- Schema validation with Pydantic-like structure
- Async handlers for all operations

## Development Guidelines

### Code Structure
- TypeScript with strict typing
- Async/await for all I/O operations
- Comprehensive error handling
- Structured logging

### Testing
- **MCP Server Tests** (`tests/mcp-server.test.ts`): Core functionality tests including tool registration, parameter passing, response formatting, and error handling
- **HTTP Transport Tests** (`tests/http-transport.test.ts`): Session management, API key authentication, and multi-tenant behavior
- **Redis Session Tests** (`tests/redis-session-manager.test.ts`): Redis connection, session storage/retrieval, rate limiting, and cross-pod session sharing
- **Test Commands**: `npm run test:mcp`, `npm run test:http`, `npm run test:redis`, `npm run test:all`

### Deployment
- Docker containerization
- Kubernetes deployment manifests
- Health check endpoints
- Graceful shutdown handling