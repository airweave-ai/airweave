---
description: MCP (Model Context Protocol) server architecture and implementation
globs: **/mcp/**
alwaysApply: false
---
# Airweave MCP Server Architecture

## Overview

The Airweave MCP Server provides search capabilities for AI assistants through the Model Context Protocol (MCP). It supports both local desktop clients and cloud-based AI platforms.

## Deployment Modes

### 1. Local Mode (Desktop AI Clients)
- **Transport**: stdio (standard input/output)
- **Target**: Claude Desktop, Cursor, and other desktop AI assistants
- **Entry Point**: `src/index.ts`
- **Installation**: npm package or npx
- **Architecture**: Single-tenant, one server instance per user's local environment
- **Authentication**: API key from environment variables

### 2. Hosted Mode (Cloud AI Platforms)
- **Transport**: Streamable HTTP (MCP 2025-03-26)
- **Target**: OpenAI Agent Builder and cloud-based AI platforms
- **Entry Point**: `src/index-http.ts`
- **Deployment**: Azure Kubernetes Service
- **URL**: `https://mcp.airweave.ai`
- **Architecture**: Multi-tenant, per-session server instances with isolated API keys
- **Authentication**: API key per request via headers or query parameters

**Key Difference**: Hosted mode creates separate `McpServer` instances for each session/API key combination, ensuring complete isolation between different users and allowing API key changes without server restart.

## Architecture Components

### Core Server (`src/server.ts`)
- **McpServer**: Main MCP server instance
- **Tool Registration**: Dynamic tool creation based on collection
- **Airweave Client**: API client for search operations
- **Environment Validation**: Configuration validation for both modes

### Streamable HTTP Server (`src/index-http.ts`)
- **Express App**: HTTP server with health checks and info endpoints
- **Streamable HTTP Transport**: Modern MCP 2025-03-26 transport for bidirectional communication
- **Request Handling**: POST `/mcp` endpoint for all MCP requests
- **Session Management**: Redis-backed distributed sessions with local caching for performance
- **Authentication**: API key extraction from headers or query parameters per request
- **Security**: API key hashing, session binding (IP/User-Agent), rate limiting, audit logging
- **Multi-Collection Discovery**: Dynamically fetches and registers tools for all collections accessible via the API key

### Tools
- **Search Tools**: `search-{readable_id}` - One search tool per collection (e.g., `search-github-test-r9xdw7`, `search-linear-o0yvkc`)
- **Config Tool**: `get-config` - Server configuration display

**Collection Discovery**: On session initialization, the server fetches all collections accessible via the provided API key from `/collections` endpoint and registers a dedicated search tool for each collection. Tool descriptions include collection name, status, and last update time to help LLMs choose the appropriate collection.

## Key Features

### Search Capabilities
- Natural language queries with full parameter control
- AI completion responses
- Pagination control (limit/offset)
- Recency bias configuration
- Score thresholds and filtering

### Authentication
- Multiple API key methods:
  - `Authorization: Bearer <key>`
  - `X-API-Key: <key>`
  - Query parameters: `?apiKey=<key>` or `?api_key=<key>`

### Error Handling
- Comprehensive error responses
- Structured logging with timestamps
- Graceful connection handling

## Configuration

### Environment Variables
- `AIRWEAVE_COLLECTION`: Target collection name
- `AIRWEAVE_BASE_URL`: API base URL (default: production)
- `PORT`: Server port (default: 8080)
- `REDIS_HOST`: Redis server hostname (default: redis)
- `REDIS_PORT`: Redis server port (default: 6379)
- `REDIS_PASSWORD`: Redis authentication password
- `REDIS_URL`: Complete Redis connection string

### Client Configuration
- API key provided by client (not server environment)
- Collection-specific tool naming
- Dynamic configuration per connection

## Implementation Details

### Combined Redis Session Management + Multi-Collection Discovery

The MCP server uses a sophisticated architecture that combines distributed session storage with dynamic collection discovery:

```typescript
// Initialize Redis session manager for distributed storage
const sessionManager = new RedisSessionManager();

// Local cache: Map session IDs to { server, transport, data }
// This cache is per-pod and reconstructed from Redis as needed
const localSessionCache = new Map<string, SessionWithTransport>();

// Fetch collections from Airweave API (called per session)
async function fetchCollections(apiKey: string, baseUrl: string): Promise<any[]> {
    const response = await fetch(`${baseUrl}/collections?limit=100`, {
        headers: { 'X-API-Key': apiKey }
    });
    return await response.json();
}

// Create server with dynamic tool registration based on collections
async function createMcpServer(apiKey: string): Promise<McpServer> {
    const collections = await fetchCollections(apiKey, baseUrl);
    const server = new McpServer({...});
    const searchToolNames: string[] = [];
    
    // Register one search tool per collection
    for (const collection of collections) {
        const airweaveClient = new AirweaveClient({ 
            collection: collection.readable_id, 
            baseUrl, 
            apiKey 
        });
        const toolName = `search-${collection.readable_id}`;
        const searchTool = createSearchTool(toolName, collection.readable_id, airweaveClient);
        
        // Enhanced description with metadata
        const enhancedDescription = `Search within '${collection.name}' collection (${collection.readable_id}).
Status: ${collection.status}
Last updated: ${new Date(collection.modified_at).toLocaleString()}
${searchTool.description}`;
        
        server.tool(searchTool.name, enhancedDescription, searchTool.schema, searchTool.handler);
        searchToolNames.push(toolName);
    }
    
    // Register config tool with actual search tool names
    const configTool = createConfigTool(searchToolNames, fallbackCollection, baseUrl, apiKey);
    server.tool(configTool.name, configTool.description, configTool.schema, configTool.handler);
    
    return server;
}

// Helper to create session objects (called when session is new or restored)
async function createSessionObjects(sessionData: SessionData, apiKey: string): Promise<SessionWithTransport> {
    // Async: Fetch collections and create server with all tools
    const server = await createMcpServer(apiKey);
    const transport = new StreamableHTTPServerTransport({ 
        sessionIdGenerator: () => sessionData.sessionId 
    });
    await server.connect(transport);
    return { server, transport, data: sessionData };
}

// Main request handler with Redis + multi-collection support
app.post('/mcp', async (req, res) => {
    const apiKey = req.headers['x-api-key'] || 
                   req.headers['authorization']?.replace('Bearer ', '');
    const sessionId = req.headers['mcp-session-id'] || generateSessionId();
    const clientIP = req.headers['x-forwarded-for']?.split(',')[0] || req.socket.remoteAddress;
    
    let session: SessionWithTransport | undefined;
    
    // Step 1: Check local cache (fastest - same pod)
    session = localSessionCache.get(sessionId);
    
    if (session) {
        // Validate API key hasn't changed
        if (!RedisSessionManager.validateApiKey(apiKey, session.data.apiKeyHash)) {
            // API key changed - recreate session with new collections
            session.transport.close();
            localSessionCache.delete(sessionId);
            
            const newSessionData = {
                sessionId,
                apiKeyHash: RedisSessionManager.hashApiKey(apiKey),
                collection, baseUrl, createdAt: Date.now(),
                lastAccessedAt: Date.now(), clientIP,
                userAgent: req.headers['user-agent']
            };
            await sessionManager.setSession(newSessionData, true);
            session = await createSessionObjects(newSessionData, apiKey);
            localSessionCache.set(sessionId, session);
        }
    } else {
        // Step 2: Check Redis (different pod or first request)
        const sessionData = await sessionManager.getSession(sessionId);
        
        if (sessionData) {
            // Restore from Redis - recreate server with collections
            session = await createSessionObjects(sessionData, apiKey);
            localSessionCache.set(sessionId, session);
        } else {
            // Step 3: New session - create with rate limiting
            const rateLimit = await sessionManager.checkRateLimit(apiKey);
            if (!rateLimit.allowed) {
                return res.status(429).json({ error: 'Rate limit exceeded' });
            }
            
            const newSessionData = {
                sessionId,
                apiKeyHash: RedisSessionManager.hashApiKey(apiKey),
                collection, baseUrl, createdAt: Date.now(),
                lastAccessedAt: Date.now(), clientIP,
                userAgent: req.headers['user-agent']
            };
            await sessionManager.setSession(newSessionData, true);
            session = await createSessionObjects(newSessionData, apiKey);
            localSessionCache.set(sessionId, session);
        }
    }
    
    // Handle request with session's transport
    await session.transport.handleRequest(req, res, req.body);
});
```

**Key Features:**
- **Redis-backed sessions**: Distributed storage, works across multiple pods
- **Local cache**: Fast access for repeated requests to same pod
- **Dynamic collection discovery**: Fetches collections per API key on session creation
- **Security**: API key hashing, session binding, rate limiting
- **Multi-tenant**: Complete isolation between API keys/organizations

### Tool Registration
- Dynamic tool names based on collection
- Schema validation with Pydantic-like structure
- Async handlers for all operations

## Development Guidelines

### Code Structure
- TypeScript with strict typing
- Async/await for all I/O operations
- Comprehensive error handling
- Structured logging

### Testing
- **MCP Server Tests** (`tests/mcp-server.test.ts`): Core functionality tests including tool registration, parameter passing, response formatting, and error handling
- **HTTP Transport Tests** (`tests/http-transport.test.ts`): Session management, API key authentication, and multi-tenant behavior
- **Redis Session Tests** (`tests/redis-session-manager.test.ts`): Redis connection, session storage/retrieval, rate limiting, and cross-pod session sharing
- **Test Commands**: `npm run test:mcp`, `npm run test:http`, `npm run test:redis`, `npm run test:all`

### Deployment
- Docker containerization
- Kubernetes deployment manifests
- Health check endpoints
- Graceful shutdown handling