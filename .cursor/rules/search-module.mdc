---
globs: **/search/**,**/collections.py
alwaysApply: false
---
# Airweave Search Rules

## Overview

The search module (`@search/`) implements a **modular, pipeline-based architecture** with composable operations.  It aims to maintain search quality and flexibility.

## Core Architecture

### Operation-Based Pipeline

```python
SearchRequest → ConfigBuilder → SearchConfig → Executor → SearchResponse
                                    ↓
                            [Operations Pipeline]
```

Each operation:
- Implements `SearchOperation` abstract base class
- Declares dependencies explicitly
- Reads/writes to shared context dictionary
- Can be optional (graceful failure)
- Executes asynchronously

### Request Flow
1. **Endpoint** → Creates/receives `SearchRequest`
2. **SearchServiceV2.search_with_request()** → Main orchestrator
3. **ConfigBuilder.build()** → Creates execution plan with operations
4. **Executor.execute()** → Runs operations in dependency order
5. **Qdrant destination** → Vector search execution
6. **Response cleaning** → Remove internal fields, format results
7. **Data Persistence** → Save search query to `search_queries` table via `CRUDSearchQuery`

### API Endpoints

Two search endpoints in `collections.py` provide different levels of functionality:

1. **GET `/{readable_id}/search`** - Basic search with query parameters
   - Simple interface for common use cases
   - Parameters: `query`, `response_type`, `limit`, `offset`, `recency_bias`
   - Internally creates a `SearchRequest` and delegates to SearchServiceV2

2. **POST `/{readable_id}/search`** - Advanced search with full control
   - Accepts `SearchRequest` body with Qdrant filter support
   - Enables metadata filtering, query interpretation, custom strategies
   - Full access to all search features and configurations

Both endpoints use **SearchServiceV2** (the new modular service), ensuring consistent behavior and quality.

### Input/Output Schemas

**SearchRequest** (input):
```python
query: str                                    # Search text
filter: Optional[Filter]                      # Qdrant filter object
limit: int = 20                              # Results per page
offset: int = 0                              # Pagination
score_threshold: Optional[float]             # Min similarity score
response_type: Literal["raw", "completion"]  # Output format
expansion_strategy: QueryExpansionStrategy   # Query variants
recency_bias: Optional[float]               # Recency weight (0-1)
enable_reranking: Optional[bool]            # LLM reranking
enable_query_interpretation: Optional[bool]  # NL filter extraction
```

**SearchResponse** (output):
```python
results: List[Dict]                         # Search results
completion: Optional[str]                   # AI-generated answer
response_type: ResponseType                 # raw/completion
status: SearchStatus                        # success/no_results
```

Result payload includes: `entity_id`, `source_name`, `md_content`, `metadata`, `score`, `breadcrumbs`, `url`

## Key Components

### Search Operations

1. **QueryInterpretation**: LLM-based filter extraction from natural language
2. **QueryExpansion**: Generates query variants (AUTO strategy by default)
3. **QdrantFilterOperation**: Applies user/LLM-extracted filters
4. **Embedding**: Generates dense (neural) and sparse (BM25) embeddings
5. **VectorSearch**: Executes hybrid search combining neural + keyword
6. **RecencyBias**: Dynamic time-based decay for recency-aware ranking
7. **LLMReranking**: Post-retrieval reranking using language models
8. **CompletionGeneration**: AI summaries from search results

### Hybrid Search

True hybrid search combining:
- **Neural embeddings**: Semantic similarity
- **BM25 sparse embeddings**: Keyword matching
- **Fusion**: Reciprocal Rank Fusion (RRF)
- Default: `"hybrid"` for optimal quality

### Dynamic Recency Scoring

```python
final_score = similarity × (1 - recency_bias + recency_bias × decay)
```
- Computes decay dynamically from data age distribution
- Respects filters when determining time ranges
- Linear decay with configurable weight (default: 0.3)
- Applied at Qdrant level for efficiency

### Configuration Defaults

**SearchConfigBuilder** centralizes all defaults:
- `DEFAULT_EXPANSION_STRATEGY = AUTO`
- `DEFAULT_RERANKING = True`
- `DEFAULT_RECENCY_BIAS = 0.3`
- `DEFAULT_SEARCH_METHOD = "hybrid"`

## Entity Architecture

### AirweaveField System

Field annotation system extending Pydantic fields:

```python
class MyEntity(ChunkEntity):
    name: str = AirweaveField(..., embeddable=True)
    created_at: datetime = AirweaveField(..., is_created_at=True)
    content: str = AirweaveField(..., embeddable=True)
```

- **Type-safe metadata** alongside field definitions
- **Embeddable marking** for search embeddings
- **Timestamp harmonization** for recency handling

### Entity Hierarchy

```
BaseEntity
├── ChunkEntity (searchable, embeddable)
│   ├── Domain entities (Jira, Linear, Notion, etc.)
│   └── Generated chunks from FileEntity
├── FileEntity (file-based content)
└── CodeFileEntity (specialized for code)
```

### Embeddable Text Generation

ChunkEntity builds structured markdown representation:
- Includes source, type, breadcrumbs, content
- Respects `embeddable=True` markers
- Caps at 12,000 characters

## Advanced Features

### Query Expansion Strategies
- **NO_EXPANSION**: Single query
- **SIMILAR**: 2-3 semantic variations
- **BROAD**: 4-5 diverse perspectives
- **AUTO**: Intelligent selection (default)

### Hybrid Search Prefetch
- Large prefetch limits (10,000+) for broad candidate sets
- Ensures both neural and BM25 contribute meaningfully
- Enables effective recency scoring across full collection

## System Metadata

### AirweaveSystemMetadata

Centralized tracking:
- **Vectors**: Dense and sparse embeddings
- **Timestamps**: Harmonized `airweave_created_at/updated_at`
- **Sync tracking**: `sync_id`, `sync_job_id`
- **Content hash**: Change detection
- **Skip flag**: Processing control

### Vector Storage

```python
vectors: Optional[List[List[float] | SparseEmbedding | None]]
# Index 0: Dense neural embedding
# Index 1: Sparse BM25 embedding
```

## Performance & Quality

### Optimizations
- Async-first design
- Parallel operation execution
- Lazy entity materialization
- Bulk search APIs
- Smart prefetching

### Intelligent Defaults
- Query expansion: AUTO
- LLM reranking: ON
- Search method: hybrid
- Recency bias: 0.3

### Graceful Degradation
- Query interpretation failure → continues without filters
- Reranking failure → returns unranked results
- Expansion failure → single query fallback

## Implementation Details

### Filter Conversion
Qdrant requires dict format, not Filter objects:
```python
# Convert Filter to dict before passing to Qdrant
filter_dict = filter.model_dump(exclude_none=True) if filter else None
await destination.search(filter=filter_dict)
```

### Result Cleaning
Automatically removes sensitive/internal fields:
- `id`, `vector` from payload
- `download_url`, `local_path`, `file_uuid`, `checksum`
- Parses JSON strings in `metadata`, `sync_metadata`

### Error Handling
HTTP status mapping in endpoints:
- Connection errors → 503 (service unavailable)
- Not found → 404
- Invalid filter → 422 (unprocessable entity)
- Others → 500

### Critical Gotchas
1. **Filter format**: Must convert to dict for Qdrant
2. **Offset with expansion**: No guarantees with multi-query search
3. **OpenAI dependency**: Falls back to LocalText2Vec if no API key
4. **Source names**: Case-sensitive in filters (e.g., "GitHub" not "github")
5. **Embedding model**: Auto-selects based on OPENAI_API_KEY presence

## Search Persistence & Analytics

### Data Persistence

Every search operation is automatically persisted to the `search_queries` table for:
- **Audit trails** and compliance
- **Performance analytics** and optimization
- **User behavior analysis** and insights
- **Search evolution tracking** over time

**SearchQuery Model** (`airweave.models.search_query`):
```python
class SearchQuery(OrganizationBase, UserMixin):
    # Core search data
    query_text: str                    # Full search query
    query_length: int                  # Character count
    search_type: str                   # "basic", "advanced", "streaming"
    response_type: Optional[str]       # "raw", "completion"
    
    # Performance metrics
    duration_ms: int                   # Execution time
    results_count: int                 # Results returned
    status: str                        # "success", "no_results", "error"
    
    # Feature usage tracking
    query_expansion_enabled: bool      # Query expansion used
    reranking_enabled: bool            # LLM reranking used
    query_interpretation_enabled: bool # Query interpretation used
    
    # Relationships
    collection_id: UUID                # Collection searched
    user_id: Optional[UUID]            # User who searched (null for API)
    api_key_id: Optional[UUID]         # API key used (null for users)
```

**CRUDSearchQuery** (`airweave.crud.crud_search_query`):
- Inherits from `CRUDBaseOrganization` for organization scoping
- Provides `get_user_search_history()` for user experience features
- Supports analytics queries for collection performance

### Analytics Integration

**Database-First Analytics**: All search data is persisted to the `search_queries` table, providing a comprehensive analytics foundation:

- **Search performance metrics** (duration, results count)
- **Feature adoption tracking** (expansion, reranking, interpretation)
- **User behavior analysis** (query patterns, search evolution)
- **Collection analytics** (usage patterns, performance trends)

**PostHog Integration**: For real-time dashboards, search data can be exported from the database to PostHog via batch jobs or streaming pipelines.

### Error Handling

Search persistence is **non-blocking**:
- If persistence fails → Search continues, error logged
- Core search functionality is never compromised

## Design Principles

1. **Modularity**: Self-contained operations
2. **Configurability**: Centralized through SearchConfig
3. **Extensibility**: Plug-in new operations via SearchOperation interface
4. **Performance**: Async, parallel, bulk operations
5. **Quality-first**: Optimized defaults
6. **Observability**: Comprehensive logging
7. **Database-first analytics**: Every search is persisted for comprehensive analysis
