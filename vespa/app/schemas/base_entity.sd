# OVERVIEW (chunk-as-document model - unified with Qdrant):
# - Each chunk is a separate document
# - entity_id: "{original_id}__chunk_{idx}"
# - original_entity_id: tracks parent entity
# - Single 3072-dim bfloat16 embedding for both matching and ranking
#
# MATCHING: hybrid (lexical + ANN) to maximize recall
# - ANN index: bfloat16 3072-dim with angular distance
# - HNSW: M=32 (higher recall), ef_construct=200
# - Pre-filtering by collection_id (approximateThreshold=0.05 for exact NN fallback)
# - targetHits: 5000 candidates (matches Qdrant)
#
# RANKING (simplified - no second-phase needed with bfloat16 precision):
# - first-phase: BM25 + closeness (all candidates)
# - global-phase: RRF fusion (top 100)
#
# NOTE: Entity-level deduplication is now handled in the backend search module
# by grouping chunks by original_entity_id and keeping the best-scoring chunk.

schema base_entity {

    document base_entity {

        # Entity ID - includes __chunk_{idx} suffix for chunk documents
        field entity_id type string {
            indexing: summary | attribute
            attribute: fast-search
        }

        field name type string {
            indexing: attribute | summary
        }

        # Breadcrumbs for hierarchy navigation
        field breadcrumbs type array<breadcrumb> {
            indexing: summary
            struct-field entity_id {
                indexing: attribute
                attribute: fast-search
            }
            struct-field name { indexing: attribute }
            struct-field entity_type {
                indexing: attribute
                attribute: fast-search
            }
        }

        # Timestamps as epoch seconds for filtering and temporal relevance
        field created_at type long {
            indexing: attribute | summary
            attribute: fast-search
        }

        field updated_at type long {
            indexing: attribute | summary
            attribute: fast-search
        }

        # =============================================================================
        # System Metadata Fields (flattened)
        # =============================================================================
        field airweave_system_metadata_collection_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_entity_type type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_sync_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_sync_job_id type string {
            indexing: attribute | summary
        }

        field airweave_system_metadata_hash type string {
            indexing: attribute | summary
        }

        # Original entity ID (before __chunk_{idx} suffix)
        # CRITICAL for entity-level deduplication in search results
        field airweave_system_metadata_original_entity_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_source_name type string {
            indexing: attribute | summary
        }

        # Chunk index within the parent entity
        field airweave_system_metadata_chunk_index type int {
            indexing: attribute | summary
        }

        # =============================================================================
        # Access Control Fields
        # =============================================================================
        field access_is_public type bool {
            indexing: attribute | summary
            attribute: fast-search
        }

        field access_viewers type array<string> {
            indexing: attribute | summary
            attribute: fast-search
        }

        # =============================================================================
        # Content Fields
        # =============================================================================

        # The chunk text (this is what gets embedded and searched)
        field textual_representation type string {
            indexing: index | summary
            index: enable-bm25
        }

        # Payload stores all other fields from the source entity (as JSON string)
        # Indexed for keyword search (BM25)
        field payload type string {
            indexing: index | summary
            index: enable-bm25
        }

        # =============================================================================
        # Embedding Field (unified 3072-dim - same as Qdrant)
        # =============================================================================

        # Single 3072-dim bfloat16 embedding for both ANN matching and ranking
        # Client sends float32, Vespa auto-converts to bfloat16 for storage
        # Uses angular distance (maps to cosine similarity)
        # HNSW parameters tuned for high recall with 5000 candidates:
        # - M=32: more links per node for better recall
        # - ef_construct=200: more neighbors explored during index building
        field dense_embedding type tensor<bfloat16>(x[3072]) {
            indexing: attribute | index
            attribute {
                distance-metric: angular
            }
            index {
                hnsw {
                    max-links-per-node: 32
                    neighbors-to-explore-at-insert: 200
                }
            }
        }
    }

    struct breadcrumb {
        field entity_id   type string {}
        field name        type string {}
        field entity_type type string {}
    }

    # Default fieldset used by userInput() / unspecified text search
    fieldset default {
        fields: textual_representation, payload
    }

    # Full summary - returns all fields needed for complete search results
    document-summary full {
        summary entity_id {}
        summary name {}
        summary breadcrumbs {}
        summary created_at {}
        summary updated_at {}
        summary airweave_system_metadata_collection_id {}
        summary airweave_system_metadata_entity_type {}
        summary airweave_system_metadata_sync_id {}
        summary airweave_system_metadata_sync_job_id {}
        summary airweave_system_metadata_hash {}
        summary airweave_system_metadata_original_entity_id {}
        summary airweave_system_metadata_source_name {}
        summary airweave_system_metadata_chunk_index {}
        summary access_is_public {}
        summary access_viewers {}
        summary textual_representation {}
        summary payload {}
    }

    # =========================================================================
    # BASE RANK PROFILE - shared inputs and functions
    # =========================================================================
    rank-profile default {
        inputs {
            # Query embedding for ranking - client sends float32
            query(query_embedding) tensor<float>(x[3072])
            # Multi-query support: q0=primary, q1-q9=expanded queries
            # Each used by nearestNeighbor operators in YQL
            query(q0) tensor<float>(x[3072])
            query(q1) tensor<float>(x[3072])
            query(q2) tensor<float>(x[3072])
            query(q3) tensor<float>(x[3072])
            query(q4) tensor<float>(x[3072])
            query(q5) tensor<float>(x[3072])
            query(q6) tensor<float>(x[3072])
            query(q7) tensor<float>(x[3072])
            query(q8) tensor<float>(x[3072])
            query(q9) tensor<float>(x[3072])
        }

        # -----------------------------------------------------------------------
        # Semantic similarity (cosine) with the single embedding
        # Uses closeness from HNSW which is already computed during matching
        # -----------------------------------------------------------------------
        function semantic_score() {
            expression: closeness(field, dense_embedding)
        }
    }

    # =========================================================================
    # HYBRID RANK PROFILE with RRF (Reciprocal Rank Fusion)
    # Simplified: no second-phase needed with bfloat16 precision
    # =========================================================================
    rank-profile hybrid-rrf inherits default {

        # -----------------------------------------------------------------------
        # Document-level scores for RRF
        # -----------------------------------------------------------------------

        # Combined BM25 score across textual_representation and payload
        function bm25_score() {
            expression: bm25(textual_representation) + bm25(payload)
        }

        # -----------------------------------------------------------------------
        # FIRST PHASE: Runs on all matched candidates
        # Combines BM25 and semantic closeness (both already computed during matching)
        # -----------------------------------------------------------------------
        first-phase {
            expression: bm25_score() + semantic_score()
        }

        # NO SECOND PHASE - bfloat16 with 3072 dimensions is accurate enough
        # No need for expensive rescoring with float32 like in Qdrant

        # -----------------------------------------------------------------------
        # GLOBAL PHASE: RRF fusion - normalizes by rank, not raw scores
        # reciprocal_rank converts each score to 1/(k+rank) where k=60
        # This makes scores comparable without training data
        # rerank-count: 100 for final ranking
        # -----------------------------------------------------------------------
        global-phase {
            rerank-count: 100
            expression {
                reciprocal_rank(bm25_score) +
                reciprocal_rank(semantic_score)
            }
        }

        # Match features for debugging and potential future model training
        match-features {
            bm25(textual_representation)
            bm25(payload)
            bm25_score
            semantic_score
        }
    }

    # =========================================================================
    # SEMANTIC-ONLY RANK PROFILE (for neural-only search)
    # =========================================================================
    rank-profile semantic-only inherits default {
        first-phase {
            expression: semantic_score()
        }
    }

    # =========================================================================
    # KEYWORD-ONLY RANK PROFILE (for BM25-only search)
    # =========================================================================
    rank-profile keyword-only inherits default {
        function bm25_score() {
            expression: bm25(textual_representation) + bm25(payload)
        }

        first-phase {
            expression: bm25_score()
        }
    }
}
