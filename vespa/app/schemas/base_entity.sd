# OVERVIEW (chunk-as-document model):
# - Each chunk is a separate document (same as Qdrant architecture)
# - entity_id: "{original_id}__chunk_{idx}"
# - original_entity_id: tracks parent entity
# - Embeddings are single values per document (not arrays)
#
# MATCHING: hybrid (lexical + ANN) to maximize recall
# - ANN index: x[96] binary packed embeddings with hamming distance for fast retrieval
# - Ranking: x[768] bfloat16 for high-precision cosine similarity
#
# RANKING (simplified for chunk-as-document):
# - first-phase: BM25 + ANN closeness (cheap, all candidates)
# - second-phase: cosine similarity with large embedding (top 200)
# - global-phase: RRF fusion (top 100)
#
# NOTE: Entity-level deduplication is now handled in the backend search module
# by grouping chunks by original_entity_id and keeping the best-scoring chunk.

schema base_entity {

    document base_entity {

        # Entity ID - includes __chunk_{idx} suffix for chunk documents
        field entity_id type string {
            indexing: summary | attribute
            attribute: fast-search
        }

        field name type string {
            indexing: attribute | summary
        }

        # Breadcrumbs for hierarchy navigation
        field breadcrumbs type array<breadcrumb> {
            indexing: summary
            struct-field entity_id {
                indexing: attribute
                attribute: fast-search
            }
            struct-field name { indexing: attribute }
            struct-field entity_type {
                indexing: attribute
                attribute: fast-search
            }
        }

        # Timestamps as epoch seconds for filtering and temporal relevance
        field created_at type long {
            indexing: attribute | summary
            attribute: fast-search
        }

        field updated_at type long {
            indexing: attribute | summary
            attribute: fast-search
        }

        # =============================================================================
        # System Metadata Fields (flattened)
        # =============================================================================
        field airweave_system_metadata_collection_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_entity_type type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_sync_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_sync_job_id type string {
            indexing: attribute | summary
        }

        field airweave_system_metadata_hash type string {
            indexing: attribute | summary
        }

        # Original entity ID (before __chunk_{idx} suffix)
        # CRITICAL for entity-level deduplication in search results
        field airweave_system_metadata_original_entity_id type string {
            indexing: attribute | summary
            attribute: fast-search
        }

        field airweave_system_metadata_source_name type string {
            indexing: attribute | summary
        }

        # Chunk index within the parent entity
        field airweave_system_metadata_chunk_index type int {
            indexing: attribute | summary
        }

        # Character positions in original document (for span-based evaluation)
        # These allow evaluating whether the correct SPAN of text was retrieved,
        # independent of how the document was chunked.
        field airweave_system_metadata_chunk_start_char type int {
            indexing: attribute | summary
        }

        field airweave_system_metadata_chunk_end_char type int {
            indexing: attribute | summary
        }

        # =============================================================================
        # Access Control Fields
        # =============================================================================
        field access_is_public type bool {
            indexing: attribute | summary
            attribute: fast-search
        }

        field access_viewers type array<string> {
            indexing: attribute | summary
            attribute: fast-search
        }

        # =============================================================================
        # Content Fields
        # =============================================================================

        # The chunk text (this is what gets embedded and searched)
        # Note: We keep this field instead of textual_representation for clarity
        field textual_representation type string {
            indexing: index | summary
            index: enable-bm25
        }

        # Payload stores all other fields from the source entity (as JSON string)
        # Indexed for keyword search (BM25)
        field payload type string {
            indexing: index | summary
            index: enable-bm25
        }

        # =============================================================================
        # Embedding Fields (single values per chunk document)
        # =============================================================================

        # Binary packed embedding for fast ANN retrieval (small and fast)
        # Uses hamming distance on packed int8 - 32x faster than float cosine
        # Pre-computed externally: 768-dim → binary → 96 int8
        field chunk_small_embedding type tensor<int8>(x[96]) {
            indexing: attribute | index
            attribute {
                distance-metric: hamming
            }
            index {
                hnsw {
                    max-links-per-node: 16
                    neighbors-to-explore-at-insert: 100
                }
            }
        }

        # High-precision embedding for ranking (not indexed for ANN - too expensive)
        # Uses angular distance which maps to cosine similarity
        # Pre-computed externally: 768-dim float
        field chunk_large_embedding type tensor<bfloat16>(x[768]) {
            indexing: attribute
            attribute {
                distance-metric: angular
            }
        }
    }

    struct breadcrumb {
        field entity_id   type string {}
        field name        type string {}
        field entity_type type string {}
    }

    # Default fieldset used by userInput() / unspecified text search
    fieldset default {
        fields: textual_representation, payload
    }

    # Full summary - returns all fields needed for complete search results
    document-summary full {
        summary entity_id {}
        summary name {}
        summary breadcrumbs {}
        summary created_at {}
        summary updated_at {}
        summary airweave_system_metadata_collection_id {}
        summary airweave_system_metadata_entity_type {}
        summary airweave_system_metadata_sync_id {}
        summary airweave_system_metadata_sync_job_id {}
        summary airweave_system_metadata_hash {}
        summary airweave_system_metadata_original_entity_id {}
        summary airweave_system_metadata_source_name {}
        summary airweave_system_metadata_chunk_index {}
        summary airweave_system_metadata_chunk_start_char {}
        summary airweave_system_metadata_chunk_end_char {}
        summary access_is_public {}
        summary access_viewers {}
        summary textual_representation {}
        summary payload {}
    }

    # =========================================================================
    # BASE RANK PROFILE - shared inputs and functions
    # =========================================================================
    rank-profile default {
        inputs {
            query(embedding) tensor<int8>(x[96])         # Binary packed for ANN matching
            query(float_embedding) tensor<float>(x[768]) # Full precision for ranking
            # Query expansion embeddings (q0=primary, q1-q9=expanded queries)
            query(q0) tensor<int8>(x[96])
            query(q1) tensor<int8>(x[96])
            query(q2) tensor<int8>(x[96])
            query(q3) tensor<int8>(x[96])
            query(q4) tensor<int8>(x[96])
            query(q5) tensor<int8>(x[96])
            query(q6) tensor<int8>(x[96])
            query(q7) tensor<int8>(x[96])
            query(q8) tensor<int8>(x[96])
            query(q9) tensor<int8>(x[96])
        }

        # -----------------------------------------------------------------------
        # Semantic similarity (cosine) with large embedding
        # -----------------------------------------------------------------------
        function semantic_similarity() {
            expression {
                reduce(query(float_embedding) * attribute(chunk_large_embedding), sum, x) /
                (sqrt(sum(pow(attribute(chunk_large_embedding), 2), x)) * sqrt(sum(pow(query(float_embedding), 2), x)))
            }
        }
    }

    # =========================================================================
    # HYBRID RANK PROFILE with RRF (Reciprocal Rank Fusion)
    # Simplified for chunk-as-document (no per-chunk aggregations)
    # =========================================================================
    rank-profile hybrid-rrf inherits default {

        # -----------------------------------------------------------------------
        # Document-level scores for RRF
        # -----------------------------------------------------------------------

        # Combined BM25 score across textual_representation and payload
        function bm25_score() {
            expression: bm25(textual_representation) + bm25(payload)
        }

        # Semantic score using closeness from ANN match (reuses HNSW graph traversal)
        function semantic_score() {
            expression: closeness(field, chunk_small_embedding)
        }

        # -----------------------------------------------------------------------
        # FIRST PHASE: Cheap, runs on all matched candidates
        # Reuses ANN match score + BM25 (both already computed during matching)
        # -----------------------------------------------------------------------
        first-phase {
            expression: bm25_score() + semantic_score()
        }

        # -----------------------------------------------------------------------
        # SECOND PHASE: Expensive high-precision similarity on top candidates
        # Uses large embedding for accurate cosine similarity
        # rerank-count: 200 candidates from first-phase
        # -----------------------------------------------------------------------
        second-phase {
            rerank-count: 200
            expression {
                firstPhase + semantic_similarity()
            }
        }

        # -----------------------------------------------------------------------
        # GLOBAL PHASE: RRF fusion - normalizes by rank, not raw scores
        # reciprocal_rank converts each score to 1/(k+rank) where k=60
        # This makes scores comparable without training data
        # rerank-count: 100 for final ranking
        # -----------------------------------------------------------------------
        global-phase {
            rerank-count: 100
            expression {
                reciprocal_rank(bm25_score) +
                reciprocal_rank(semantic_similarity)
            }
        }

        # Match features for debugging and potential future model training
        match-features {
            bm25(textual_representation)
            bm25(payload)
            bm25_score
            semantic_score
            semantic_similarity
        }
    }
}
